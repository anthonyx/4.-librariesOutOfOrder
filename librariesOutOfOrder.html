<script src="./simpletest.js"></script>
<script>


// Task: Rewrite librarySystem so we can create libraries with dependencies out of order

/* Requirements:
    - It should return a library object given library name
    - It should create a new library given library name and library callback
    - It should create a new library given library name, library callback, and library dependencies
    - It should not run the callback if the same library previously exists
    - It should create new library even if library dependencies do not exist yet
    - Libraries should only be accessible within the function, not globally
*/

(function() {
    var libraryStorage = {};

    function librarySystem(libraryName, libraryCallback, dependencies) {
        // Feature 1: Store library
        if(arguments.length > 1) {
            libraryStorage[libraryName] = {
                libraryCallback: libraryCallback,
                dependencies: dependencies,
                // By default, we will set the library to null until we want to return the library
                library: null
            };
        // Feature 2: Return library
        } else {
            // If library does not exist, create library
            if(libraryStorage[libraryName].library === null) {
                // Check whether dependencies property is an array 
                // If not, set it to empty array
                if(Array.isArray(libraryStorage[libraryName].dependencies) === false) {
                    libraryStorage[libraryName].dependencies = [];
                }
                // Create libraryCallbackArguments by running librarySystem on each element in dependencies array
                libraryCallbackArguments = libraryStorage[libraryName].dependencies.map(function(element) {
                    return librarySystem(element);
                });

                // Set library equal to return value of libraryCallback applied with libraryCallbackArguments
                libraryStorage[libraryName].library = libraryStorage[libraryName].libraryCallback.apply(null, libraryCallbackArguments);
            }

            return libraryStorage[libraryName].library;
        }
    }

    window.librarySystem = librarySystem;
})();


// Tests
tests({
    'It should store a library given library name and library callback.': function() {
        // How do I access libraryStorage to confirm it has been stored?
        // libraryStorage can only be accessed using librarySystem
        // If accessing using librarySystem, then this test and the next test would be dependent on each other
        function newLibraryCallback() {
            return 'newLibrary';
        }

        librarySystem('library', newLibraryCallback);

        eq(librarySystem('library'), 'newLibrary');
    },
    'It should return a library object given an existing library name.': function() {
        function newLibraryCallback() {
            return 'newLibrary';
        }

        librarySystem('library', newLibraryCallback);

        eq(librarySystem('library'), 'newLibrary');
    },
    'It should store a library given library name, library callback, and library dependencies.': function() {
        function firstLibraryCallback() {
            return 'Anthony';
        }
        // Create first library
        librarySystem('firstLibrary', firstLibraryCallback);

        function secondLibraryCallback(firstLibrary) {
            return 'My name is ' + firstLibrary;
        }
        // Create second library using first library
        librarySystem('secondLibrary', secondLibraryCallback, ['firstLibrary']);

        eq(librarySystem('secondLibrary'), 'My name is Anthony');
    },
    'If library exists, it should not run the library callback again.': function() {
        // 2 requirements for not running the callback again:
            // 1. library name previously exists
            // 2. library value is equal to callback return value
                // Issue with this is that we need to run callback everytime to compare the values
                // But what if it is an object? Then we cannot compare since it is based on memory addresses
                // Compare the functions themselves? 
                    // Unless the parameters passed into the function are different
                    // Then we need to store the function as well

        var counter = 0;
        function counterLibraryCallback() {
            counter++;
            return '';
        }

        librarySystem('counterLibrary', counterLibraryCallback);
        librarySystem('counterLibrary', counterLibraryCallback);
        librarySystem('counterLibrary');
        librarySystem('counterLibrary');

        eq(counter, 1);
    },
    'It should properly return a library stored with library dependencies that did not exist when library was created.': function() {
        librarySystem('workBlurb', function(name, company) {
          return name + ' works at ' + company;
        }, ['name', 'company']);

        librarySystem('name', function() {
          return 'Gordon';
        }, []);

        librarySystem('company', function() {
          return 'Watch and Code';
        }, []);

        eq(librarySystem('workBlurb'), 'Gordon works at Watch and Code');
    }
});

</script>